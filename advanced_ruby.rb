#!/usr/bin/env ruby
puts 'eval'
# Ex. 1
eval 'puts 2 + 2' # 4:  Note that while 4 is displayed, 4is not returned as the result of the whole eval expression. puts always returns nil.
puts eval ('2 + 2') # 4:  This returns 4 from eval

# Ex. 2
num = 15
my_code = %Q(#{num} * 2)
puts eval(my_code) # 30
# The eval method simply executes (or evaluates) the code passed to it and returns the result. Example 1 made eval execute puts 2 + 2, whereas the second used string interpolation to build a expression of 15 * 2, which was then evaluated and printed to the screen using puts.


puts 'BINDING'
# Binding refers to a context, scope, or state of execution. A binding includes things such as the current value of variables and other details of the execution environment. It’s possible to pass a binding to eval and to have eval execute the supplied code under that binding rather than the current one. In this way, you can keep things that happen with eval separate from the main execution context of your code.
# Here’s an example:
def binding_elsewhere
  x = 20
  return binding
end
remote_binding = binding_elsewhere
x = 10
eval("puts x") # 10
eval("puts x", remote_binding) # 20 : note eval accepts optional paramater here
# The above code can be extended as:
eval("x = 20") # 20
eval("x = 50", remote_binding) # 50
eval("puts x") # 20
eval("puts x", remote_binding) # 50

puts 'how to use class_eval, module_eval, and instance_eval'
# class_eval, module_eval, and instance_eval can evaluate code within the context of classes, modules, and object instances, respectively.
# class_eval is ideal for adding methods to a class dynamically:
class Person
end
def add_accessor_to_person(acc_name)
  Person.class_eval %Q(
    attr_accessor :#{acc_name}
  )
end
john = Person.new
add_accessor_to_person(:name)
add_accessor_to_person(:gender)
add_accessor_to_person(:age)
john.name = 'John Bull'
john.age = 25
john.gender = 'male'
puts "#{john.name} is #{john.age} years old and is a #{john.gender}"
# Note that a method such as add_accessor_to_person can be used inside some class to perform duties similar to what attr_accessor does in classes. This is made possible after the 'String' class has been exteded with the add_accessor_to_person or whatever other method is being extended to the String class. A longer version of creating your own attr_accessor is:
class Class 
  def add_accessor(acc_arr)
    acc_arr.each do |el|
      self.class_eval %Q{
        def #{el}
          @#{el}
        end

        def #{el}=(val)
          @#{el} = val
        end
      }
    end
  end
end

class Dog
end
skippy = Dog.new
Dog.add_accessor([:name, :age, :color])
skippy.name, skippy.age, skippy.color = 'Skippy', 5, 'brown'
puts skippy.name
puts skippy.age
puts skippy.color


puts 'some other ways to run other programs from ruby'
# There are three simple ways to run another program from within Ruby: the 'system' method (defined in the Kernel module), backtick syntax (``), and delimited input literals (%x{}). Using 'sysetm' is ideal when you want to run another program and aren’t concerned with its output, whereas you should use backticks when you want the output of the remote program returned.
# These lines demonstrate three ways of running the system’s date program:
$ system('date') # true
$ `date` # "Sun Apr 30 15:30:10 PDT 2017\n"
$ %x{date} # "Sun Apr 30 15:30:10 PDT 2017\n" : note it is same as above

puts 'TRANSFERING EXECUTION TO ANOTHER PROGRAM'
# Sometimes it’s desirable to jump immediately to another program and cease execution of the current program. This is useful if you have a multistep process and have written an application for each. To end the current program and invoke another, simply use the exec method in place of system. For example: 
# if the code below is within a file that is being run,
puts 2 + 2 # This code would run
puts 'The Lord is my shephered' # And this code would run
exec 'ruby some_other_file.rb' # Execution is transfered to some_otheer_file.rb
puts 'I shall not want' # This code would not run
# The first tow lines would run, and then the content of some_other_file.rb would run after that.


puts 'RUNNING TWO PROGRAMS AT THE SAME TIME'
# Forking is where an instance of a program (a process) duplicates itself, resulting in two processes of that program running concurrently. You can run other programs from this second process by using exec, and the first (parent) process will continue running the original program.
# 'fork' is a method provided by the Kernel module that creates a fork of the current process. It returns the child process’s process ID in the parent, but 'nil' in the child process — you can use this to determine which process a script is in. The following example forks the current process into two processes, and only executes the exec command within the child process (the process generated by the fork):
if fork.nil?
  exec 'ruby some_other_file.rb'
end
puts 'This script now runs alongside some other file'

# If the other program (being run by exec) is expected to finish at some point, and you want to wait for it to finish executing before doing something in the parent program, you can use Process.wait to wait for all child processes to finish before continuing. Here’s an example:
child = fork do
  sleep 5 # implements a 5 second delay
  puts "Child says 'hi'!"
end
puts 'Waiting for the child process .....'
Process.wait child # waits for the child process to finish before continuing
puts 'All done!'


puts 'INTERACTING WITH ANOTHER PROGRAM'
# Sometimes you might want to pass data back and forth between two separate programs. Ruby’s IO module has a popen method that allows you to run another program and have an I/O stream between it and the current program. Ex:
ls = IO.popen("ls", "r")
while line = ls.gets
  puts line
end
ls.close
# In the example code, you open up an I/O stream with 'ls' (the Unix command to list the contents of the current directory. You read the lines one by one, as with other forms of I/O streams, and close the stream when you’re done. Similarly, you can also open a program with a read/write I/O stream and handle data in both directions:
handle = IO.popen("other_program", "r+")
handle.puts "send input to other program"
handle.close_write
while line = handle.gets
  puts line
end
# Note that the reason for handle_close_write is to close the I/O stream’s writing stream, thereby sending any data waiting to be written out to the remote program. IO also has a flush method that can be used if the write stream needs to remain open.


puts 'SAFELY HANDLING DATA AND DANGEROUS METHODS Handling'
# It’s common for Ruby applications to be used in situations where the operation of a program relies on data from an outside source. This data cannot always be trusted, and it can be useful to protect your machines and environments from unfortunate situations caused by bad data or code. Ruby can be made safer both by considering external data to be tainted and by setting a safe level under which the Ruby interpreter restricts what features are made available to the code it executes. Consider a simple program that illustrates why checking for tainted data can be crucial:
while x = gets
  puts "=> #{eval(x)}"
end
# The above code is similar to how pry. It accepts line after line of input from the user and immediately executes it. running:
$ 2 + 2 # => 4
$ 'hello.length' # => 5
$ <some dangerous code> # 
# There are situations where you need to check whether data has potentially been tainted by the outside world. You can check if an object is considered tainted by using the tainted? method:
x = 'Hello world!'
puts x.tainted? # false
y = [x, x, x]
puts y.tainted? # false 
z = 20 + 30
z.tainted? # false
a = File.open('some_file').readlines.first
puts a.tainted? # true because no such file exist in the current directory
b = [a]
puts b.tainted? # false because it is merely an array containing a fake file.

# It is also possible to force an object to be seen as untainted/tainted by calling the untaint/tainted method on the object. For example, here’s an extremely safe version of your Ruby interpreter:
while x = gets # note that all data accepted from the user is considered tainted
  next if x.tainted? # so this is incredibly useless because nothing will run
  puts "=> #{eval(x)}" # we can write a code_is_safe? method instead
end

def code_is_safe?(code) # onlu for demo purposes, not to be used.
  # code =~/[a`;*-,]/ ? false : true
  code.include?('a') ? false : true
end

while x = gets
  x.untaint if code_is_safe?(x)
  next if x.tainted?
  puts "=> #{eval(x)}"
end


puts 'THREADS'
# Thread is short for thread of execution. You use threads to split the execution of a program into multiple parts that can be run concurrently. For example, a program designed to e-mail thousands of people at once might split the task between 20 different threads that all send e-mail at once. Such parallelism is faster than processing one item after another, especially on systems with more than one CPU, because different threads of execution can be run on different processors. It can also be faster because rather than wasting time waiting for a response from a remote machine, you can continue with other operations. Exs. of a basc thread include:
threads = []
10.times do
  thread = Thread.new do
    10.times { |i| print i; $stdout.flush; sleep rand(2) }
  end

  threads << thread
end
threads.each { |thread| thread.join } # 21312151112341234253532642362344644573375756485958647885669756967798789678788989999.
# You create an array to hold your Thread objects so that you can easily keep track of them. Then you create ten threads, sending the block of code to be executed in each thread to Thread.new, and add each generated thread to the array. Note that when you create a thread, it can access any variables that are within scope at that point. However, any local variables that are then created within the thread are entirely local to that thread. This is similar to the behavior of other types of code blocks. Once you’ve created the threads, you wait for all of them to complete before the program finishes. You wait by looping through all the thread objects in threads and calling each thread's join method. The join method makes the main program wait until a thread’s execu- tion is complete before continuing. In this way, you make sure all the threads are complete before exiting. 
# The example code above has created ten Ruby threads whose sole job is to count and sleep randomly. This results in the preceding pseudo-random output.
# Rather than sleeping, the threads could have been fetching web pages, performing math operations, or sending e-mails. In fact, Ruby threads are ideal for almost every situation where concurrency within a single Ruby program is desired.

# More advanced Thread Operations include:
# Waiting for Threads to Finish Redux
# When you waited for your threads to finish by using the join method, you could have specified a timeout value (in seconds) for which to wait. If the thread doesn’t finish within that time, join returns nil. Here’s an example where each thread is given only 1 second to execute:
threads.each do |thread|
  puts "Thread #{thread.object_id} didn't finish in 1s" unless thread.join(1)
end
# It’s possible to get a global list of all threads running within your program using Thread.list.
10.times do
  Thread.new do
    10.times do |i|
      print i; $stdout.flush; sleep rand(2)
    end
  end
end
Thread.list.each { |thread| thread.join }
# However, keeping your own list of threads is essential if you’re likely to have more than one group of threads working within an application, and you want to keep them separate from one another when it comes to using join or other features. The list of threads also includes the main thread representing the main program’s thread of execution. You can check to see which thread is main by comparing the thread object to Thread.main, like so:
Thread.list.each { |thread| thread.join unless thread == Thread.main }

# Sometiimes, Thread operations occur from within Threads themselves.
# Threads aren’t just tiny, dumb fragments of code. They have the ability to talk with the Ruby thread scheduler and provide updates on their status. For example a thread can stop itself:
Thread.new do
  10.times do |i|
    print i 
    $stdout.flush
    Thread.stop
  end
end
# Every time the thread created above prints a number to the screen, it stops itself. It can then only be restarted or resumed by the parent program calling the run method on the thread, like so:
Thread.lsit.each { |thread| thread.run }
# A thread can also tell the Ruby thread scheduler that it wants to pass execution over to another thread. The technique of voluntarily ceding control to another thread is often known as cooperative multitasking, because the thread or process itself is saying that it’s okay to pass execution on to another thread or process. Used properly, cooperative multitasking can make threading even more efficient, as you can code in pass requests at ideal locations. Here’s an example showing how to cede control from a thread:
2.times { Thread.new { 10.times { |i| print i; $stdout.flush; Thread.pass }}}
Thread.list.each { |thread| thread.join unless thread == Thread.main } # 36457678899
# In the above example, execution flip-flops between the two threads, causing the pattern shown in the results.
# For more on Threads and alternatives to Threads, find out about Fibers. A motivation to use fibers over threads in some situations is efficiency. Creating hundreds of fibers is a lot faster than creating the equivalent threads. The disadvantage of fibers to threads, however, is that fibers are not preemptive at all—you can only run one fiber at a time (within a single thread), and you have to do the scheduling. In some situations, of course, this might be a plus!

# In situations where extremely high performance is desirable, it can be a good idea to write the computationally intensive code in a more powerful but less expressive language, and then call that code from Ruby. Luckily there’s a library for Ruby called RubyInline, created by Ryan Davis and Eric Hodel, that makes it possible to write code in other more powerful languages within your Ruby code. It’s most often used to write high-performance code in the C or C++ languages, and we’ll focus on this in this section.
# Installing RubyInline on Unix-related platforms (such as Linux and OS X) is easy with RubyGems: $ gem install RubyInline

puts 'Unicode, Character Encodings, and UTF-8 Support'
# Unicode is the industry standard way of representing characters from every writing system (character set) in the world. It’s the only viable way to be able to manage multiple different alphabets and character sets in a reasonably standard context.





